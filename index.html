<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Name Picker Wheel</title>
<style>
  body { font-family: Arial, sans-serif; text-align: center; background: #f0f0f0; }
  #controls { margin: 20px; }
  select, button, label { font-size: 16px; margin: 5px; }
  #wheelCanvas { margin: 20px auto; display: block; background: white; border-radius: 50%; border: 4px solid #333; }
  textarea { margin-top: 10px; font-size: 14px; }
</style>
</head>
<body>
<h1>Name Picker Wheel</h1>

<div id="controls">
  <select id="groupSelect"></select>
  <button id="spinButton">Spin</button>
  <label>
    <input type="checkbox" id="allowRepeats"> Allow repeats
  </label>
  <button id="increaseFont">Increase Font</button>
  <button id="decreaseFont">Decrease Font</button>
</div>

<canvas id="wheelCanvas" width="500" height="500"></canvas>

<div>
  <label for="removedNames">Removed Names (10% chance):</label><br>
  <textarea id="removedNames" rows="4" cols="40" readonly></textarea>
</div>

<script>
const groups = {};
let currentNames = [];
let fontSize = 16; // starting font size
let currentRotation = 0;
let spinning = false;

const groupSelect = document.getElementById("groupSelect");
const wheelCanvas = document.getElementById("wheelCanvas");
const ctx = wheelCanvas.getContext("2d");
const removedNamesBox = document.getElementById("removedNames");

const textFiles = {
  "Red 1": "red1.txt",
  "Red 3": "red3.txt",
  "Red 4": "red4.txt",
  "Green 5": "green5.txt",
  "Green 6": "green6.txt",
  "Green 7": "green7.txt"
};

// Load names from text files
async function loadText(file) {
  const res = await fetch(file);
  const text = await res.text();
  return text.split(/\r?\n/).map(n => n.trim()).filter(n => n.length > 0);
}

// Initialize groups
async function init() {
  for (const [name, file] of Object.entries(textFiles)) {
    groups[name] = await loadText(file);
  }
  updateGroupSelect();
}

function updateGroupSelect() {
  groupSelect.innerHTML = "";
  for (const group in groups) {
    const option = document.createElement("option");
    option.value = group;
    option.textContent = group;
    groupSelect.appendChild(option);
  }
  loadGroup(groupSelect.value);
}

groupSelect.addEventListener("change", () => loadGroup(groupSelect.value));

function loadGroup(groupName) {
  currentNames = [...groups[groupName]];
  drawWheel(currentRotation);
}

// Draw wheel
function drawWheel(rotation = 0) {
  ctx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);
  const numSlices = currentNames.length;
  if (numSlices === 0) return;
  const angleStep = (2 * Math.PI) / numSlices;

  ctx.save();
  ctx.translate(250, 250);
  ctx.rotate(rotation);

  currentNames.forEach((name, i) => {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.fillStyle = `hsl(${(i * 360) / numSlices}, 70%, 60%)`;
    ctx.arc(0, 0, 250, i * angleStep, (i + 1) * angleStep);
    ctx.fill();

    ctx.save();
    ctx.rotate(i * angleStep + angleStep / 2);
    ctx.fillStyle = "black";
    ctx.textAlign = "right";
    ctx.font = `${fontSize}px Arial`;
    ctx.fillText(name, 230, 5);
    ctx.restore();
  });
  ctx.restore();

  // Draw fixed arrow at top
  ctx.beginPath();
  ctx.moveTo(250, 20);
  ctx.lineTo(240, 0);
  ctx.lineTo(260, 0);
  ctx.fillStyle = "red";
  ctx.fill();
}

// Compute the index under top arrow
function getTopIndex() {
  if (currentNames.length === 0) return null;
  const angleStep = (2 * Math.PI) / currentNames.length;
  const normalized = currentRotation % (2 * Math.PI);
  const topIndex = Math.floor((2 * Math.PI - normalized) / angleStep) % currentNames.length;
  return topIndex;
}

// Spin button: animate wheel with slow down and 10% removal
document.getElementById("spinButton").addEventListener("click", () => {
  if (spinning || currentNames.length === 0) return;
  spinning = true;

  const spins = 5 + Math.random() * 3; // random rotations
  const targetRotation = currentRotation + spins * 2 * Math.PI;
  const duration = 4000; // slower spin duration
  const startRotation = currentRotation;
  const startTime = performance.now();

  function animate(now) {
    const t = (now - startTime) / duration;
    if (t < 1) {
      const ease = 1 - Math.pow(1 - t, 3); // cubic ease out
      currentRotation = startRotation + (targetRotation - startRotation) * ease;
      drawWheel(currentRotation);
      requestAnimationFrame(animate);
    } else {
      currentRotation = targetRotation;
      drawWheel(currentRotation);

      // 10% chance to remove top name
      const topIndex = getTopIndex();
      if (topIndex !== null && Math.random() <= 0.1) {
        const removedName = currentNames.splice(topIndex, 1)[0];
        removedNamesBox.value += removedName + "\n";
      }

      drawWheel(currentRotation); // redraw after removal
      spinning = false;
    }
  }

  requestAnimationFrame(animate);
});

// Font size buttons
document.getElementById("increaseFont").addEventListener("click", () => {
  fontSize += 2;
  drawWheel(currentRotation);
});
document.getElementById("decreaseFont").addEventListener("click", () => {
  fontSize = Math.max(8, fontSize - 2);
  drawWheel(currentRotation);
});

init();
</script>
</body>
</html>

