<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Name Picker Wheel</title>
<style>
  body { font-family: Arial, sans-serif; text-align: center; background: #f0f0f0; }
  #wheelCanvas { margin: 20px auto; display: block; background: white; border-radius: 50%; border: 4px solid #333; }
  #controls { margin: 20px; }
  select, button, label { font-size: 16px; margin: 5px; }
  #result { font-size: 24px; margin-top: 15px; font-weight: bold; }
  #repeatToggle { position: absolute; top: 10px; right: 10px; }
</style>
</head>
<body>
<h1>Random Name Picker Wheel</h1>

<div id="controls">
  <select id="groupSelect"></select>
  <button id="spinButton">Spin</button>
  <label id="repeatToggle">
    <input type="checkbox" id="allowRepeats"> Allow repeats
  </label>
</div>

<canvas id="wheelCanvas" width="500" height="500"></canvas>
<div id="result"></div>

<script>
const groups = {};
let currentNames = [];
let usedIndices = [];
let spinning = false;
let currentRotation = 0;

const groupSelect = document.getElementById("groupSelect");
const wheelCanvas = document.getElementById("wheelCanvas");
const ctx = wheelCanvas.getContext("2d");
const resultDiv = document.getElementById("result");
const spinButton = document.getElementById("spinButton");
const allowRepeats = document.getElementById("allowRepeats");

const textFiles = {
  "Red 1": "red1.txt",
  "Red 3": "red3.txt",
  "Red 4": "red4.txt",
  "Green 5": "green5.txt",
  "Green 6": "green6.txt",
  "Green 7": "green7.txt"
};

// Load names from text files
async function loadText(file) {
  const res = await fetch(file);
  const text = await res.text();
  return text.split(/\r?\n/).map(n => n.trim()).filter(n => n.length > 0);
}

// Initialize groups
async function init() {
  for (const [name, file] of Object.entries(textFiles)) {
    groups[name] = await loadText(file);
  }
  updateGroupSelect();
}

function updateGroupSelect() {
  groupSelect.innerHTML = "";
  for (const group in groups) {
    const option = document.createElement("option");
    option.value = group;
    option.textContent = group;
    groupSelect.appendChild(option);
  }
  loadGroup(groupSelect.value);
}

groupSelect.addEventListener("change", () => loadGroup(groupSelect.value));

function loadGroup(groupName) {
  currentNames = [...groups[groupName]];
  usedIndices = [];
  currentRotation = 0;
  drawWheel(currentRotation);
}

// Draw wheel and arrow
function drawWheel(rotation = 0) {
  ctx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);
  const numSlices = currentNames.length;
  if (numSlices === 0) return;
  const angleStep = (2 * Math.PI) / numSlices;

  // Draw wheel rotated
  ctx.save();
  ctx.translate(250, 250);
  ctx.rotate(rotation);
  currentNames.forEach((name, i) => {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.fillStyle = `hsl(${(i * 360) / numSlices}, 70%, 60%)`;
    ctx.arc(0, 0, 250, i * angleStep, (i + 1) * angleStep);
    ctx.fill();

    // Draw name
    ctx.save();
    ctx.rotate(i * angleStep + angleStep / 2);
    ctx.fillStyle = "black";
    ctx.textAlign = "right";
    ctx.font = "16px Arial";
    ctx.fillText(name, 230, 5);
    ctx.restore();
  });
  ctx.restore();

  // Draw arrow 5° CCW from rightmost edge, pointing to center
  const arrowAngle = (360 - 5) * Math.PI / 180; // 5° CCW from horizontal
  const wheelRadius = 250;
  const baseLength = 40; // arrow width outside wheel
  const tipX = 250 + Math.cos(arrowAngle) * wheelRadius;
  const tipY = 250 + Math.sin(arrowAngle) * wheelRadius;
  const leftX = tipX + Math.cos(arrowAngle + Math.PI/2) * baseLength;
  const leftY = tipY + Math.sin(arrowAngle + Math.PI/2) * baseLength;
  const rightX = tipX + Math.cos(arrowAngle - Math.PI/2) * baseLength;
  const rightY = tipY + Math.sin(arrowAngle - Math.PI/2) * baseLength;

  ctx.beginPath();
  ctx.moveTo(tipX, tipY);
  ctx.lineTo(leftX, leftY);
  ctx.lineTo(rightX, rightY);
  ctx.fillStyle = "red";
  ctx.fill();
}

// Spin the wheel
spinButton.addEventListener("click", spinWheel);

function spinWheel() {
  if (spinning || currentNames.length === 0) return;
  spinning = true;

  const numSlices = currentNames.length;
  const angleStep = (2 * Math.PI) / numSlices;

  // Determine available indices
  let availableIndices = allowRepeats.checked ? Array.from(Array(numSlices).keys()) : Array.from(Array(numSlices).keys()).filter(i => !usedIndices.includes(i));
  if (availableIndices.length === 0) { usedIndices = []; availableIndices = Array.from(Array(numSlices).keys()); }

  // Randomly pick target slice
  const targetIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
  if (!allowRepeats.checked) usedIndices.push(targetIndex);

  // Total rotation = multiple spins + target slice aligned with pointer
  const spins = 5;
  const arrowAngle = (360 - 5) * Math.PI / 180; // same angle as drawn
  const targetRotation = spins * 2 * Math.PI + targetIndex * angleStep - arrowAngle; // align slice under arrow

  const duration = 4000;
  const start = performance.now();

  function animate(now) {
    const t = (now - start) / duration;
    if (t < 1) {
      const ease = 1 - Math.pow(1 - t, 3); // cubic ease out
      currentRotation = targetRotation * ease;
      drawWheel(currentRotation);
      requestAnimationFrame(animate);
    } else {
      currentRotation = targetRotation;
      drawWheel(currentRotation);
      // Compute which slice is at pointer
      const normalized = (currentRotation + arrowAngle) % (2 * Math.PI);
      const topIndex = Math.floor((2 * Math.PI - normalized) / angleStep) % currentNames.length;
      resultDiv.textContent = "Selected: " + currentNames[topIndex];
      spinning = false;
    }
  }

  requestAnimationFrame(animate);
}

init();
</script>
</body>
</html>
