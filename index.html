<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Name Picker Wheel</title>
<style>
  body { font-family: Arial, sans-serif; text-align: center; background: #f0f0f0; }
  #wheelCanvas { margin: 20px auto; display: block; background: white; border-radius: 50%; border: 4px solid #333; }
  #controls { margin: 20px; }
  select, button, label { font-size: 16px; margin: 5px; }
  #result { font-size: 24px; margin-top: 15px; font-weight: bold; }
  #repeatToggle { position: absolute; top: 10px; right: 10px; }
</style>
</head>
<body>
<h1>Random Name Picker Wheel</h1>

<div id="controls">
  <select id="groupSelect"></select>
  <button id="spinButton">Spin</button>
  <label id="repeatToggle">
    <input type="checkbox" id="allowRepeats"> Allow repeats
  </label>
</div>

<canvas id="wheelCanvas" width="500" height="500"></canvas>
<div id="result"></div>

<script>
const groups = {};
let currentNames = [];
let usedIndices = [];
let spinning = false;
let currentRotation = 0;

const groupSelect = document.getElementById("groupSelect");
const wheelCanvas = document.getElementById("wheelCanvas");
const ctx = wheelCanvas.getContext("2d");
const resultDiv = document.getElementById("result");
const spinButton = document.getElementById("spinButton");
const allowRepeats = document.getElementById("allowRepeats");

const textFiles = {
  "Red 1": "red1.txt",
  "Red 3": "red3.txt",
  "Red 4": "red4.txt",
  "Green 5": "green5.txt",
  "Green 6": "green6.txt",
  "Green 7": "green7.txt"
};

// Load names from text file
async function loadText(file) {
  const res = await fetch(file);
  const text = await res.text();
  return text.split(/\r?\n/).map(n => n.trim()).filter(n => n.length > 0);
}

// Initialize groups
async function init() {
  for (const [name, file] of Object.entries(textFiles)) {
    groups[name] = await loadText(file);
  }
  updateGroupSelect();
}

function updateGroupSelect() {
  groupSelect.innerHTML = "";
  for (const group in groups) {
    const option = document.createElement("option");
    option.value = group;
    option.textContent = group;
    groupSelect.appendChild(option);
  }
  loadGroup(groupSelect.value);
}

groupSelect.addEventListener("change", () => loadGroup(groupSelect.value));

function loadGroup(groupName) {
  currentNames = [...groups[groupName]];
  usedIndices = [];
  currentRotation = 0;
  drawWheel(currentRotation);
}

// Draw wheel
function drawWheel(rotation = 0) {
  ctx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);
  const numSlices = currentNames.length;
  if (numSlices === 0) return;
  const angleStep = (2 * Math.PI) / numSlices;

  // Draw wheel rotated
  ctx.save();
  ctx.translate(250, 250);
  ctx.rotate(rotation);
  currentNames.forEach((name, i) => {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.fillStyle = `hsl(${(i * 360) / numSlices}, 70%, 60%)`;
    ctx.arc(0, 0, 250, i * angleStep, (i + 1) * angleStep);
    ctx.fill();

    // Draw name
    ctx.save();
    ctx.rotate(i * angleStep + angleStep / 2);
    ctx.fillStyle = "black";
    ctx.textAlign = "right";
    ctx.font = "16px Arial";
    ctx.fillText(name, 230, 5);
    ctx.restore();
  });
  ctx.restore();

  // Draw pointer (fixed)
  ctx.beginPath();
  ctx.moveTo(250, 0);
  ctx.lineTo(240, 20);
  ctx.lineTo(260, 20);
  ctx.fillStyle = "red";
  ctx.fill();
}

// Spin the wheel
spinButton.addEventListener("click", spinWheel);

function spinWheel() {
  if (spinning || currentNames.length === 0) return;
  spinning = true;

  const numSlices = currentNames.length;
  const angleStep = (2 * Math.PI) / numSlices;

  // Pick a random slice for final position if no repeats or repeats allowed
  let availableIndices = allowRepeats.checked ? Array.from(Array(numSlices).keys()) : Array.from(Array(numSlices).keys()).filter(i => !usedIndices.includes(i));
  if (availableIndices.length === 0) { usedIndices = []; availableIndices = Array.from(Array(numSlices).keys()); }

  const selectedIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
  if (!allowRepeats.checked) usedIndices.push(selectedIndex);

  // Calculate total rotation so that selectedIndex ends at top
  const spins = 5; // full rotations
  const targetRotation = spins * 2 * Math.PI + selectedIndex * angleStep + angleStep / 2;

  const duration = 4000; // spin time in ms
  const start = performance.now();

  function animate(now) {
    const t = (now - start) / duration;
    if (t < 1) {
      const ease = 1 - Math.pow(1 - t, 3); // cubic ease out
      currentRotation = targetRotation * ease;
      drawWheel(currentRotation);
      requestAnimationFrame(animate);
    } else {
      currentRotation = targetRotation;
      drawWheel(currentRotation);
      // Determine selected slice based on rotation
      const normalized = currentRotation % (2 * Math.PI);
      const topIndex = Math.floor((2 * Math.PI - normalized) / angleStep) % currentNames.length;
      resultDiv.textContent = "Selected: " + currentNames[topIndex];
      spinning = false;
    }
  }

  requestAnimationFrame(animate);
}

init();
</script>
</body>
</html>
